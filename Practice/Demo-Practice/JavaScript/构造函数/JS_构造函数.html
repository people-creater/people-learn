<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>构造函数</title>
</head>
<body>
<script>

    //命名以大写字母开头
    //只能通过new关键字调用



    // function Person(name, age) {
    //     this.name = name;
    //     this.age = age;
    // }
    // const p1 = new Person('张三', 18);




    //执行nwe调用函数的行为被称为实例化
    //实例化构造函数时没有参数时可以省略
    //不需要写return返回值即为新创建的对象
    //new Object() new Data()  也是实例化构造函数



    // function Goods(name,price){
    //     this.name = name;
    //     this.price = price;
    // }
    // const mi = new Goods('小米', 1999);
    // console.log(mi);
    // const huawei = new Goods('华为', 2999);
    // console.log(huawei);
    // const oppo = new Goods('oppo', 1999);
    // console.log(oppo);



    //实例化执行过程
    //创建新的空对象
    //构造函数this 指向新对象
    //执行构造函数代码，修改this，添加新的属性
    //返回新对象


    //通过构造函数创建的对象称为实例对象
    //构造函数创建的实例对象彼此独立互不影响
    //实例对象中的属性和方法称为实例成员，构造函数中的属性和方法称为静态成员



    //内置构造函数        基本数据类型也有专门的构造函数被称为包装类型
    //引用类型有Object String Number Boolean Array Date RegExp Error


    //Object.keys(obj)    Object.values(obj)
    const o = {name: '张三', age: 18}
    console.log(Object.keys(o))//返回数组

    // const oo = {}
    // console.log(Object.assign(oo.o))//对象的拷贝
    // 使用场景，给对象添加属性



    //Array
    //forEach 遍历数组
    //map     迭代数组    返回新数组
    //filter  过滤数组    返回新数组
    //reduce  累计器
    //arr,reduce(function(上一次值,当前值){}，初始值)
    // array.reduce( (pre, cur) => pre + cur , 0)//不写初始值，默认为数组的第一个元素
    //
    //
    // const arr = [
    //     {
    //         name:'小米',
    //         price:1999
    //     },
    //     {
    //         name:'华为',
    //         price:2999
    //     },
    // ]
    // const huawei = arr.find(item=>item.name==='华为')
    // console.log(huawei)



    //JS实现面向对象需要构造函数，但会浪费内存

    //原型
    //构造函数通过分配的函数是所有对象所共享的
    //每一个构造函数都有一个prototype属性，指向另一个对象，即为原型对象
    //可以把不变的方法直接定义在prototype对象上，这样所有对象的实列就可以共享这些方法
    //构造函数和原型对象中的this都指向实例化的对象

    function Star(uname,age){
        //公共的属性写在构造函数中
        this.uname = uname;
        this.age = age;
        // this.sing = function(){
        //     console.log('sing')
        // }
    }
    const lilei = new Star('lilei',18)
    //公共的方法写在原型对象中
    Star.prototype.sing = function(){
        console.log('sing')
    }
    lilei.sing()


    const arr = [1,2,3,4,5]
    Array.prototype.max = function(){
        return Math.max(...arr)
    }
    console.log(arr.max())


    //constructor属性
    //每个原型对象都有constructor属性，指向构造函数，简单理解，指向我的爸爸，我是有爸爸的孩子
    console.log(Star.prototype.constructor === Star)
    //使用场景
    //如果有多个对象的方法 我们可以给原型对象采取对象形式赋值


    function Stars(uname){
        this.uname = uname;
    }
    Stars.prototype = {
        sing:function (){
            console.log('sing')
        },
        dance:function (){
            console.log('dance')
        }
    }
    console.log(Stars.prototype.constructor)//指向Object


    //但是会覆盖构造函数原型对象原来的内容,这样修改后的原型对象constructor就不再指向当前构造函数
    //此时我们可以在修改后的原型对象中天降一个constructor指向原来的构造函数

    // function Stars(uname){
    //     this.uname = uname;
    // }
    // Stars.prototype = {
    //     constructor:Stars,
    //     sing:function (){
    //         console.log('sing')
    //     },
    //     dance:function (){
    //         console.log('dance')
    //     }
    // }
    // console.log(Stars.prototype.constructor)//指向Stars



    //对象原型 _proto_ 已弃用

    // 替代 obj.__proto__ 的读取操作
    const prototype = Object.getPrototypeOf(obj);

    // 替代 obj.__proto__ = prototype 的赋值操作
    Object.setPrototypeOf(obj, prototype);

    // 创建一个以指定对象为原型的新对象
    const newObj = Object.create(prototype);

</script>
</body>
</html>